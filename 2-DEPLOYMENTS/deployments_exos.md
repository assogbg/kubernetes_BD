# Deployments

## My first deployments

On the POD section, we created our first pods with the following.

Let's see how we can create deployments. A deployment is a supervisor for pods, giving you fine-grained control over how and when a new pod version is rolled out as well as rolled back to a previous state.

Kubernetes provides wonderful CLI commands in order to generate a deployment:

> kubectl create deployment --dry-run=client -o yaml <deploymentName> --image=<dockerImage> --replicas=<NumberOfReplicas> --port=<PortToExpose> > Mydeployment.yaml

> kubectl create -f Mydeployment.yaml

#### create 2 deployments
Create two deployments with the following parameters:
- docker image : image assogbg/pod_second:v1, name : deployfirst, number of replicas: 2, port: 9999
- docker image : assogbg/pod_second:v1, name : deploysecond, number of replicas: 2, port: 7777

<details>
    <summary>
    **Hints**
    </summary>

    - > kubectl create deployment --dry-run=client -o yaml deployfirst --image=assogbg/pod_second:v1 --replicas=2 --port=9999 > first_deploy.yaml

    - > kubectl create deployment --dry-run=client -o yaml deploysecond --image=assogbg/pod_second:v1 --replicas=2 --port=7777 > second_deploy.yaml

</details>

#### Deployments Descriptions
Highlights the created Deployments, ReplicaSet and Pods.
Pay attention on the results (labels, ID, Name, Status, ...)

<details>
    <summary>
    **Hints**
    </summary>

    - > kubectl get pods <podName> --show-labels -o wide

    - > kubectl get deploy,rs

    - > kubectl describe <entity> <entityName>


</details>

<details>
    <summary>
    **Solutions**
    </summary>

    > kubectl get pods deployfirst -o wide

    ```
    NAME                         READY   STATUS    RESTARTS   AGE   IP               NODE       NOMINATED NODE   READINESS GATES   
    deployfirst-59ffbfbf4f-5829f    1/1     Running   0          42s   172.17.0.6       minikube   <none>           <none>            
    deployfirst-59ffbfbf4f-mmhlw    1/1     Running   0          42s   172.17.0.8       minikube   <none>           <none>            
    deploysecond-79b985b446-4zzxj   1/1     Running   0          74s   172.17.0.3       minikube   <none>           <none>            
    deploysecond-79b985b446-rp8xd   1/1     Running   0          74s   172.17.0.2       minikube   <none>           <none>            
    ```
    PLEASE PAY ATTENTION TO THE LABELS. You actually find two labels for each pods :
    - 1 is specified in your deployment specs (app: deploysecond or app:deployfirst)
    - 2nd (pod-template-hash) is generated by the replicaset controller (encapsulated     in your deployment)

    > kubectl get deploy,rs
    ```
    NAME                        READY   UP-TO-DATE   AVAILABLE   AGE
    deployment.apps/deployfirst    2/2     2            2           12m
    deployment.apps/deploysecond   2/2     2            2           13m

    NAME                                   DESIRED   CURRENT   READY   AGE
    replicaset.apps/deployfirst-59ffbfbf4f    2         2         2       12m
    replicaset.apps/deploysecond-79b985b446   2         2         2       13m
    ```

</details>

## Rollout and Rollback

#### Rollout history

We will now look at an awesome feature of deployments that allow us to create rollout when a deployment change and the rollback to a previous version.

First, list the number of rollout revision for the deployment 'deploysecond'. Then, check the details of this rollout and compare it to your original deployment yaml.

<details>
    <summary>
    **Hints**
    </summary>

    - > kubectl rollout history deployment deploysecond

    - > kubectl rollout history deployment deploysecond --revision=1

</details>

<details>
    <summary>
    **Solutions**
    </summary>

    > kubectl rollout history deployment deploysecond
    ```
    deployment.apps/deploysecond
    REVISION  CHANGE-CAUSE
    1         <none>
    ```

    > kubectl rollout history deployment deploysecond --revision=1
    ```
    deployment.apps/deployfirst with revision #1
    Pod Template:
      Labels:	app=deploysecond
    	pod-template-hash=59ffbfbf4f
      Containers:
       deployfirst:
        Image:	assogbg/pod_second:v3
        Port:	7777/TCP
        Host Port:	0/TCP
        Environment:	<none>
        Mounts:	<none>
      Volumes:	<none>
    ```

    We see that it keeps tracks of the revision (the changes you've made to your     deployment).

    If we go further into that, we see that there is a limit to the version that your     deployment is going to keep as revision in its history.
    This is actually the main added value of a deployment : you can easily rollout/    rollbacks.
    In addition to that, when it processes a rollout/rollback, a new replicaset will be     created and it will progressively creates new pods before the previous replicaset     terminates its pods.
    Therefore, there won't be any downtime.

    > kubectl rollout history deployment deploysecond -o yaml
    ```
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      annotations:
        deployment.kubernetes.io/revision: "1"
      creationTimestamp: "2020-04-30T02:30:56Z"
      generation: 1
      labels:
        app: deploysecond
      name: deploysecond
      namespace: default
      resourceVersion: "213539"
      selfLink: /apis/apps/v1/namespaces/default/deployments/deploysecond
      uid: ad934a2b-6d3b-4d94-80cc-5cbcf36555ef
    spec:
      progressDeadlineSeconds: 600
      replicas: 2
      revisionHistoryLimit: 10
      selector:
        matchLabels:
          app: deployfirst
      strategy:
        rollingUpdate:
          maxSurge: 25%
          maxUnavailable: 25%
        type: RollingUpdate
      template:
        metadata:
          creationTimestamp: null
          labels:
            app: deploysecond
        spec:
          containers:
          - image: assogbg/pod_second:v1
            imagePullPolicy: IfNotPresent
            name: deploysecond
            ports:
            - containerPort: 7777
              protocol: TCP
            resources: {}
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
          dnsPolicy: ClusterFirst
          restartPolicy: Always
          schedulerName: default-scheduler
          securityContext: {}
          terminationGracePeriodSeconds: 30
    status:
      availableReplicas: 2
      conditions:
      - lastTransitionTime: "2020-04-30T02:30:59Z"
        lastUpdateTime: "2020-04-30T02:30:59Z"
        message: Deployment has minimum availability.
        reason: MinimumReplicasAvailable
        status: "True"
        type: Available
      - lastTransitionTime: "2020-04-30T02:30:56Z"
        lastUpdateTime: "2020-04-30T02:30:59Z"
        message: ReplicaSet "deploysecond-59ffbfbf4f" has successfully progressed.
        reason: NewReplicaSetAvailable
        status: "True"
        type: Progressing
      observedGeneration: 1
      readyReplicas: 2
      replicas: 2
      updatedReplicas: 2
    ```

</details>

#### new Rollout

We will now set a new image to our deployment 'assogbg/pod_second:v2', check your rollout, deployments and ReplicaSet, see that a new version has been added.

<details>
    <summary>
    **Hints**
    </summary>

    - > kubectl set image deployment <deploymenntName> <containerName>=<newImage> --record

    - > kubectl rollout status deployment <deploymentName>

    - > kubectl rollout history deployment <deploymentName>

</details>

<details>
    <summary>
    **Solutions**
    </summary>
    > kubectl set image deployment deploysecond second=assogbg/pod_second:v2 --record

    > kubectl rollout status deployment deploysecond
    ```
    deployment "deploysecond" successfully rolled out
    ```

    > kubectl rollout history deployment deploysecond
    ```
    deployment.apps/deployfirst
    REVISION  CHANGE-CAUSE
    1         <none>
    2         kubectl set image deployment deploysecond second=assogbg/pod_second:v2 --    record=true
    ```

    ### check pods and replicasets
    > kubectl get pods -o wide

    ```
    NAME                         READY   STATUS    RESTARTS   AGE    IP                NODE       NOMINATED NODE   READINESS GATES   
    deployfirst-6ffb8758f6-qblzg    1/1     Running   0          104s   172.17.0.9        minikube   <none>           <none>     
    deployfirst-6ffb8758f6-vgqzr    1/1     Running   0          100s   172.17.0.10       minikube   <none>           <none>     
    deploysecond-79b985b446-4zzxj   1/1     Running   0          32m    172.17.0.3        minikube   <none>           <none>         
    deploysecond-79b985b446-rp8xd   1/1     Running   0          32m    172.17.0.2        minikube   <none>           <none>         
    ```
    > kubectl get deploy,rs
    ```
    NAME                        READY   UP-TO-DATE   AVAILABLE   AGE
    deployment.apps/deployfirst    2/2     2            2           33m
    deployment.apps/deploysecond   2/2     2            2           34m

    NAME                                   DESIRED   CURRENT   READY   AGE
    replicaset.apps/deploysecond-59ffbfbf4f    0         0         0       33m
    replicaset.apps/deployfirst-6ffb8758f6    2         2         2       34m46s
    replicaset.apps/deploysecond-79b985b446   2         2         2       3m26s
    ```

    Please PAY ATTENTION TO replicasets:
    we now see that deploysecond deployment has had 2 different replicasets
    - the initial one with desired and current nb of replicas set to zero
    - the new one with desired and current nb of replicas set to 2

    This also illustrates the role of the replicaset controller that makes sure current     and desired state are equal.

</details>

#### rollback
Let's say that we now want to rollback our last upgrade and move back to the first revision. Then check the different existing revisions and print as a yaml the last revision.


<details>
    <summary>
    **Hints**
    </summary>

    - > kubectl rollout undo deployment <deploymentName> --to-revision=<revisionNunber>

    - > kubectl rollout history deployment <deploymentName>

    - > kubectl rollout history deployment <deploymentName> --revision=<revisionNumber>

</details>

<details>
    <summary>
    **Solutions**
    </summary>

    > kubectl rollout undo deployment deploysecond --to-revision=1

    > kubectl rollout history deployment deploysecond
    ```
    deployment.apps/deploysecond
    REVISION  CHANGE-CAUSE
    2         kubectl set image deployment deployfirst deploysecond=assogbg/    pod_second:v2 --record=true
    3         <none>
    ```
    >kubectl rollout history deployment deploysecond --revision=3
    ```
    deployment.apps/deploysecond with revision #3
    Pod Template:
      Labels:	app=deploysecond
    	pod-template-hash=59ffbfbf4f
      Containers:
       deployfirst:
        Image:	assogbg/pod_second:v1
        Port:	7777/TCP
        Host Port:	0/TCP
        Environment:	<none>
        Mounts:	<none>
      Volumes:	<none>
    ```

</details>

## Additional exercice

- Create the deployment located in: ***https://raw.githubusercontent.com/openshift-evangelists/kbe/main/specs/deployments/d09.yaml***

- Check your deployment, replicaSet, pods (naming, numbers, status, ...)

- At this point in time the sise containers running in the pods are configured to return the version 0.9. Let’s verify this from within the cluster using curl: ***curl -s "yourHost":9876/info***

- Let’s now see what happens if we change that version to 1.0 in an updated deployment yaml : ***https://raw.githubusercontent.com/openshift-evangelists/kbe/main/specs/deployments/d10.yaml***

- Check your deployment, replicaSet, pods (naming, numbers, status, ...)

- Verify that you get the version 1.0 while curling your pod.

- Check your rollout history

- undo your deployment rollout to the revision 1

- Check your rollout history, deployments, rs and pods

- Which version should you receive while curling your pod ? Try it yourself
